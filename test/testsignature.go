package main

import (
	"bytes"
	"crypto/rand"
	bls "dumbo_fabric/crypto/signature/bls"
	"fmt"
	"log"
	"strconv"

	"os"
)

func main() {

	arg := os.Args[1]
	num, _ := strconv.Atoi(arg)
	//testbug(num)
	//testbugmsg(num)
	testQC(num)

}

func testbug(num int) {
	gopath := os.Getenv("GOPATH")
	keypath := "/src/dumbo_fabric/config/"

	var sigms []bls.Signature

	for i := 0; i < num; i++ {
		sig := bls.NewSignature()
		sig.Init(gopath+keypath, num, i+1)
		sigms = append(sigms, sig)
	}

	QCagg := []byte{49, 32, 49, 57, 100, 100, 56, 102, 56, 97, 53, 50, 102, 52, 51, 98, 48, 100, 51, 55, 54, 102, 99, 48, 48, 49, 101, 51, 97, 54, 49, 57, 98, 97, 50, 57, 55, 55, 99, 98, 100, 98, 53, 100, 97, 55, 101, 52, 53, 55, 101, 48, 49, 101, 51, 101, 100, 55, 97, 99, 54, 55, 98, 54, 101, 51, 49, 52, 56, 101, 97, 49, 98, 99, 102, 49, 49, 101, 51, 100, 53, 98, 53, 98, 98, 54, 48, 57, 57, 53, 52, 56, 55, 48, 48, 102, 48, 57, 32, 101, 56, 97, 49, 55, 57, 54, 55, 101, 52, 100, 50, 53, 48, 55, 55, 53, 50, 54, 53, 99, 57, 56, 57, 53, 57, 51, 99, 55, 51, 53, 49, 57, 56, 55, 53, 48, 48, 48, 102, 56, 53, 48, 49, 52, 101, 98, 50, 100, 102, 48, 55, 48, 48, 50, 49, 99, 98, 100, 100, 53, 53, 100, 56, 98, 97, 52, 99, 101, 101, 101, 49, 53, 52, 55, 99, 99, 102, 50, 101, 53, 57, 49, 54, 97, 55, 50, 102, 101, 57, 102, 56, 57, 99, 53}

	msgs := make([][]byte, 4)
	msgs[0] = []byte{211, 71, 99, 199, 164, 85, 54, 150, 65, 146, 224, 100, 19, 70, 47, 90, 234, 54, 139, 186, 74, 230, 180, 138, 151, 17, 81, 130, 168, 238, 167, 181, 0, 0, 0, 10, 0, 0, 0, 1, 0, 0, 0, 1}
	msgs[1] = []byte{84, 112, 105, 24, 243, 71, 72, 123, 164, 34, 95, 50, 120, 244, 141, 69, 89, 222, 144, 237, 177, 183, 138, 86, 97, 39, 153, 73, 220, 148, 222, 170, 0, 0, 0, 8, 0, 0, 0, 2, 0, 0, 0, 1}
	msgs[2] = []byte{92, 213, 49, 215, 105, 128, 13, 225, 134, 67, 77, 23, 201, 21, 240, 2, 31, 33, 109, 188, 128, 204, 124, 213, 29, 211, 200, 249, 119, 14, 37, 45, 0, 0, 0, 9, 0, 0, 0, 3, 0, 0, 0, 1}
	msgs[3] = []byte{136, 36, 53, 243, 59, 18, 253, 126, 114, 96, 113, 84, 180, 47, 159, 12, 160, 47, 46, 120, 84, 39, 59, 148, 77, 163, 52, 14, 69, 247, 85, 211, 0, 0, 0, 4, 0, 0, 0, 4, 0, 0, 0, 1}

	memss := make([][]int32, 4)
	memss[0] = []int32{4, 2}
	memss[1] = []int32{4, 1}
	memss[2] = []int32{4, 2}
	memss[3] = []int32{3, 1}

	for i := 0; i < 4; i++ {
		if !sigms[i].QCAggregateVerify(QCagg, msgs, memss) {
			fmt.Println("wrong QC agg", i)
		}
	}

}

func testbugmsg(num int) {
	gopath := os.Getenv("GOPATH")
	keypath := "/src/dumbo_fabric/config/"

	var sigms []bls.Signature
	bugQCagg := []byte{49, 32, 99, 49, 48, 54, 101, 99, 49, 101, 54, 102, 98, 51, 53, 97, 52, 97, 55, 50, 50, 51, 52, 53, 55, 48, 52, 100, 97, 54, 48, 54, 51, 99, 56, 102, 54, 97, 98, 56, 100, 50, 53, 97, 50, 51, 99, 102, 48, 49, 97, 55, 50, 57, 100, 101, 48, 53, 49, 98, 100, 101, 53, 102, 48, 55, 51, 100, 101, 53, 55, 56, 101, 102, 97, 100, 56, 102, 53, 52, 48, 56, 97, 101, 54, 53, 56, 50, 97, 53, 57, 100, 55, 97, 53, 48, 52, 32, 54, 101, 52, 56, 49, 48, 101, 55, 55, 48, 52, 57, 50, 54, 52, 55, 51, 98, 102, 52, 53, 99, 98, 55, 55, 98, 54, 57, 99, 57, 97, 57, 56, 98, 51, 49, 51, 97, 50, 98, 49, 99, 97, 101, 50, 97, 52, 97, 52, 97, 57, 49, 99, 49, 56, 100, 98, 55, 50, 51, 97, 101, 56, 57, 56, 49, 99, 102, 57, 52, 48, 54, 98, 48, 97, 98, 55, 54, 57, 53, 53, 101, 102, 101, 101, 51, 54, 57, 52, 100, 101, 50, 101, 49}

	bugqcs := make([][]byte, 4)
	bugqcs[0] = []byte{49, 32, 53, 51, 97, 99, 98, 51, 102, 55, 100, 50, 102, 98, 97, 48, 57, 53, 54, 102, 100, 49, 53, 53, 97, 100, 100, 97, 53, 101, 102, 97, 52, 52, 98, 54, 99, 99, 100, 55, 55, 52, 53, 53, 55, 50, 100, 54, 97, 51, 49, 52, 48, 54, 49, 56, 98, 102, 98, 49, 57, 98, 48, 99, 99, 53, 48, 51, 99, 98, 53, 49, 56, 102, 50, 54, 57, 51, 98, 102, 102, 53, 54, 101, 56, 49, 97, 48, 56, 97, 99, 52, 97, 98, 51, 97, 54, 32, 53, 98, 53, 50, 102, 97, 48, 100, 48, 48, 48, 101, 49, 52, 101, 100, 102, 54, 49, 55, 56, 53, 52, 100, 54, 99, 52, 49, 99, 51, 53, 54, 51, 49, 101, 98, 50, 57, 54, 57, 98, 49, 53, 99, 55, 97, 52, 48, 53, 55, 56, 52, 100, 55, 51, 99, 52, 98, 98, 51, 98, 56, 97, 52, 53, 98, 98, 98, 98, 50, 56, 101, 53, 56, 49, 48, 53, 52, 48, 49, 99, 48, 57, 100, 51, 100, 53, 97, 52, 57, 54, 102, 102, 98, 53}
	bugqcs[1] = []byte{49, 32, 102, 50, 102, 57, 50, 49, 51, 98, 55, 53, 99, 97, 98, 56, 98, 51, 57, 98, 49, 100, 98, 56, 53, 98, 101, 57, 52, 50, 54, 57, 52, 51, 102, 49, 102, 52, 100, 50, 57, 101, 51, 50, 99, 51, 99, 97, 102, 97, 57, 52, 52, 48, 52, 54, 56, 101, 56, 99, 56, 50, 100, 55, 102, 101, 97, 97, 56, 99, 54, 101, 55, 51, 102, 52, 48, 100, 53, 101, 56, 97, 101, 50, 51, 48, 100, 97, 55, 50, 51, 99, 53, 54, 50, 56, 55, 32, 49, 52, 101, 99, 54, 54, 51, 102, 101, 99, 51, 50, 49, 101, 52, 97, 99, 101, 99, 49, 57, 100, 49, 51, 51, 57, 50, 48, 51, 53, 53, 54, 55, 97, 55, 53, 99, 49, 97, 99, 50, 49, 51, 56, 99, 97, 102, 101, 102, 48, 49, 56, 56, 99, 55, 48, 48, 53, 52, 51, 98, 48, 51, 49, 53, 98, 99, 100, 50, 100, 51, 100, 54, 54, 48, 48, 53, 48, 53, 97, 52, 49, 102, 48, 56, 55, 100, 97, 49, 49, 52, 48, 101, 55, 97, 56}
	bugqcs[2] = []byte{49, 32, 49, 54, 101, 97, 52, 101, 54, 53, 54, 102, 51, 55, 52, 51, 55, 54, 101, 51, 55, 51, 97, 51, 101, 55, 53, 48, 52, 99, 101, 54, 49, 50, 54, 100, 56, 51, 53, 98, 57, 53, 52, 49, 48, 52, 53, 55, 52, 56, 49, 51, 51, 102, 52, 102, 50, 54, 99, 102, 53, 56, 97, 50, 100, 56, 51, 56, 51, 57, 55, 51, 98, 56, 56, 101, 49, 57, 53, 100, 50, 49, 48, 55, 48, 51, 50, 97, 55, 52, 99, 101, 53, 54, 97, 97, 48, 52, 32, 49, 51, 55, 55, 50, 100, 55, 97, 100, 99, 56, 50, 51, 56, 57, 54, 48, 53, 100, 48, 101, 48, 48, 99, 99, 50, 49, 49, 54, 55, 102, 49, 101, 48, 99, 53, 97, 97, 100, 101, 50, 51, 51, 54, 49, 98, 52, 54, 55, 51, 57, 53, 101, 99, 57, 99, 99, 54, 56, 56, 98, 102, 55, 53, 100, 51, 50, 98, 54, 98, 99, 54, 102, 51, 102, 54, 102, 98, 57, 55, 54, 53, 52, 49, 98, 49, 97, 57, 97, 56, 56, 56, 50, 100, 52, 102}
	bugqcs[3] = []byte{49, 32, 49, 101, 53, 100, 100, 53, 48, 49, 54, 101, 99, 54, 52, 51, 100, 100, 55, 100, 100, 99, 51, 50, 101, 101, 55, 52, 50, 55, 56, 50, 50, 52, 55, 49, 51, 97, 102, 54, 98, 55, 53, 102, 52, 97, 52, 53, 50, 50, 54, 57, 97, 99, 97, 49, 49, 98, 100, 100, 54, 54, 98, 48, 53, 57, 98, 51, 54, 55, 51, 49, 48, 51, 102, 51, 49, 48, 98, 51, 100, 99, 101, 52, 51, 48, 100, 99, 54, 101, 54, 100, 48, 100, 98, 102, 97, 32, 54, 48, 53, 102, 97, 101, 97, 52, 53, 99, 54, 53, 99, 51, 54, 98, 49, 99, 51, 51, 57, 98, 49, 48, 56, 56, 98, 50, 55, 51, 52, 57, 101, 50, 57, 51, 99, 57, 51, 53, 48, 97, 48, 102, 55, 102, 101, 54, 101, 98, 51, 57, 102, 101, 99, 51, 101, 100, 102, 98, 52, 50, 97, 51, 50, 98, 51, 54, 98, 102, 98, 52, 101, 50, 52, 53, 48, 100, 50, 55, 101, 49, 55, 54, 57, 54, 56, 57, 49, 56, 99, 55, 49, 50, 98}

	msgs := make([][]byte, 4)
	msgs[0] = []byte{189, 175, 207, 107, 132, 6, 249, 44, 36, 84, 68, 156, 197, 6, 225, 138, 221, 77, 10, 127, 92, 102, 74, 160, 66, 184, 142, 138, 27, 79, 2, 215, 0, 0, 0, 50, 0, 0, 0, 1, 0, 0, 0, 1}
	msgs[1] = []byte{180, 243, 231, 58, 222, 4, 32, 153, 35, 219, 125, 157, 39, 14, 250, 157, 123, 92, 82, 204, 111, 26, 106, 160, 219, 23, 53, 29, 215, 247, 79, 156, 0, 0, 0, 53, 0, 0, 0, 2, 0, 0, 0, 1}
	msgs[2] = []byte{237, 36, 253, 244, 141, 176, 117, 159, 37, 99, 63, 240, 125, 34, 125, 122, 9, 131, 28, 100, 69, 85, 12, 165, 231, 184, 58, 171, 246, 115, 183, 243, 0, 0, 0, 51, 0, 0, 0, 3, 0, 0, 0, 1}
	msgs[3] = []byte{196, 15, 53, 66, 71, 47, 143, 194, 20, 106, 163, 3, 9, 135, 142, 214, 148, 175, 131, 245, 24, 52, 88, 113, 153, 14, 166, 100, 24, 83, 73, 67, 0, 0, 0, 56, 0, 0, 0, 4, 0, 0, 0, 1}

	memss := make([][]int32, 4)
	memss[0] = []int32{3, 2}
	memss[1] = []int32{1, 3}
	memss[2] = []int32{2, 4}
	memss[3] = []int32{3, 1}

	for i := 0; i < num; i++ {
		sig := bls.NewSignature()
		sig.Init(gopath+keypath, num, i+1)
		sigms = append(sigms, sig)
	}

	//generate QC
	count := 0
	QCs := make([][]byte, num)

	for i := 0; i < num; i++ {
		sigs := make([][]byte, 2)
		for j := 0; j < 2; j++ {
			signature := sigms[memss[i][j]-1].Sign(msgs[i])
			sigs[j] = signature
			if !sigms[j].Verify(int(memss[i][j])-1, sigs[j], msgs[i]) {
				panic("wrong single sign")
			}
		}

		QCs[i] = sigms[i].BatchSignature(sigs, msgs[i], memss[i])
		if !sigms[num-1].BatchSignatureVerify(QCs[i], msgs[i], memss[i]) {
			panic("wrong batch verify")
		}
		count++
	}

	for i := 0; i < 4; i++ {
		if !bytes.Equal(QCs[i], bugqcs[i]) {
			fmt.Println("my qc", i, ":", QCs[i])
		}
	}

	myQCagg := sigms[num-1].QCAggregate(QCs, msgs, memss)
	fmt.Println("len of QCagg:", len(myQCagg))
	for i := 0; i < num; i++ {
		if !sigms[i].QCAggregateVerify(myQCagg, msgs, memss) {
			panic(fmt.Sprintln("wrong QC agg", i))
		}
	}

	if !bytes.Equal(myQCagg, bugQCagg) {
		fmt.Println(myQCagg)
	}

}

func testQC(num int) {
	gopath := os.Getenv("GOPATH")
	keypath := "/src/dumbo_fabric/config/"

	var sigms []bls.Signature

	bugqcs := []byte{49, 32, 53, 51, 97, 99, 98, 51, 102, 55, 100, 50, 102, 98, 97, 48, 57, 53, 54, 102, 100, 49, 53, 53, 97, 100, 100, 97, 53, 101, 102, 97, 52, 52, 98, 54, 99, 99, 100, 55, 55, 52, 53, 53, 55, 50, 100, 54, 97, 51, 49, 52, 48, 54, 49, 56, 98, 102, 98, 49, 57, 98, 48, 99, 99, 53, 48, 51, 99, 98, 53, 49, 56, 102, 50, 54, 57, 51, 98, 102, 102, 53, 54, 101, 56, 49, 97, 48, 56, 97, 99, 52, 97, 98, 51, 97, 54, 32, 53, 98, 53, 50, 102, 97, 48, 100, 48, 48, 48, 101, 49, 52, 101, 100, 102, 54, 49, 55, 56, 53, 52, 100, 54, 99, 52, 49, 99, 51, 53, 54, 51, 49, 101, 98, 50, 57, 54, 57, 98, 49, 53, 99, 55, 97, 52, 48, 53, 55, 56, 52, 100, 55, 51, 99, 52, 98, 98, 51, 98, 56, 97, 52, 53, 98, 98, 98, 98, 50, 56, 101, 53, 56, 49, 48, 53, 52, 48, 49, 99, 48, 57, 100, 51, 100, 53, 97, 52, 57, 54, 102, 102, 98, 53}

	msgs := []byte{189, 175, 207, 107, 132, 6, 249, 44, 36, 84, 68, 156, 197, 6, 225, 138, 221, 77, 10, 127, 92, 102, 74, 160, 66, 184, 142, 138, 27, 79, 2, 215, 0, 0, 0, 50, 0, 0, 0, 1, 0, 0, 0, 1}

	memss := make([][]int32, 6)
	memss[0] = []int32{1, 2}
	memss[1] = []int32{1, 3}
	memss[2] = []int32{1, 4}
	memss[3] = []int32{2, 3}
	memss[4] = []int32{2, 4}
	memss[5] = []int32{3, 4}

	for i := 0; i < num; i++ {
		sig := bls.NewSignature()
		sig.Init(gopath+keypath, num, i+1)
		sigms = append(sigms, sig)
	}

	//generate QC
	for i := 0; i < 6; i++ {
		sigs := make([][]byte, 2)
		for j := 0; j < 2; j++ {
			signature := sigms[memss[i][j]-1].Sign(msgs)
			sigs[j] = signature
			if !sigms[j].Verify(int(memss[i][j])-1, sigs[j], msgs) {
				panic("wrong single sign")
			}
		}
		QC := sigms[1].BatchSignature(sigs, msgs, memss[i])
		if !sigms[num-1].BatchSignatureVerify(QC, msgs, memss[i]) {
			panic("wrong batch verify")
		}
		if bytes.Equal(QC, bugqcs) {
			fmt.Println("miss match:", i)
		}
	}

	if !sigms[1].BatchSignatureVerify(bugqcs, msgs, []int32{3, 2}) {
		fmt.Println("wrong bug qc")
	}
}

func test(num int) {
	th := (num-1)/3*2 + 1
	gopath := os.Getenv("GOPATH")
	keypath := "/src/dumbo_fabric/config/"

	var sigms []bls.Signature
	msgs := make([][]byte, num)

	for i := 0; i < num; i++ {
		sig := bls.NewSignature()
		sig.Init(gopath+keypath, num, i+1)
		sigms = append(sigms, sig)

		msgs[i] = make([]byte, 1024*1024)
		_, err := rand.Read(msgs[i])
		if err != nil {
			log.Fatalf("error while generating random string: %s", err)
		}
	}

	//generate QC
	count := 0
	QCs := make([][]byte, num)
	memss := make([][]int32, num)

	for i := 0; i < num; i++ {
		sigs := make([][]byte, th)
		mems := make([]int32, th)
		for j := 0; j < th; j++ {
			signature := sigms[(j+count)%num].Sign(msgs[i])
			sigs[j] = signature
			mems[j] = int32((j+count)%num + 1)
			if !sigms[j].Verify((j+count)%num, sigs[j], msgs[i]) {
				panic("wrong single sign")
			}
		}
		memss[i] = bytes2int32s(int32s2bytes(mems, num), num)

		QCs[i] = sigms[i].BatchSignature(sigs, msgs[i], mems)
		if !sigms[num-1].BatchSignatureVerify(QCs[i], msgs[i], mems) {
			panic("wrong batch verify")
		}
		count++
	}

	QCagg := sigms[num-1].QCAggregate(QCs, msgs, memss)
	fmt.Println("len of QCagg:", len(QCagg))
	for i := 0; i < num; i++ {
		if !sigms[i].QCAggregateVerify(QCagg, msgs, memss) {
			panic(fmt.Sprintln("wrong QC agg", i))
		}
	}

}

func int32s2bytes(ids []int32, max int) []byte {
	tags := make([]bool, max)

	for _, id := range ids {
		tags[id-1] = true
	}

	b := make([]byte, (len(tags)+7)/8)
	for i, v := range tags {
		if v {
			b[i/8] |= 1 << uint(i%8)
		}
	}
	return b
}

func bytes2int32s(aggids []byte, max int) []int32 {
	var result []int32
	for i, b := range aggids {
		for j := uint(0); j < 8; j++ {
			index := i*8 + int(j)
			if index >= max {
				break
			}
			if (b >> j & 1) == 1 {
				result = append(result, int32(i)*8+int32(j)+1)
			}
		}
	}
	return result
}

